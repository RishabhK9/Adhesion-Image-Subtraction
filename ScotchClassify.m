%__author__ = "Bryant Rodriguez"
%__email__ = "bryant1.rodriguez@famu.edu"
%__coauthors__ = " "
%__date__ = "07/19/2021"
%__version__ = "v0.8"

% Description: Classifies a single adhesion tape test image (after converting
% it to binary black and white) as per ASTM D3359.
% Takes a single baseline image and converts it to black and white. 
% The image should be an image that is known to be of class 5 (no flaking).  
% Then take a different image of unknown class and classify it.

% To-Do List: 
% 1. Properly crop all input images (hopefully automatically) so that they 
% are all of the same size or aspect ratio. 
% 2. Develop code so that this works properly.
% 2. Utilize a better method of making images black and white.
% 4. Alternatively, think of a better way to do all of this.


%The code does not currently work in its current iteration. Feel free to
%change any part of it or even start from scratch if desired.


function ScotchClassify(baseFileName, newFileName)  
    baseFileName = 'BW_ink_base.png'; 
    newFileName = '1_Cu_test.jpg';
    %Uncomment the filenames and change to
    %desired filenames
    
    %Create base B&W image (using image of class 5) and use to find 
    %baseline ratio of black to white pixels in image.
    %Use this ratio to compare image being classified.
    
    baseRatio = GetBaseline(baseFileName);
    
    %Take second image and convert to black and white.
    
    Cu_ink = imread(newFileName); % Input image

    [BW_ink, ~] = segmentImage(Cu_ink); %convert to B&W given colored image
    
    BW_ink = imcomplement(BW_ink); %invert blacks and whites
    
    imshow(BW_ink);
    %find black:white ratio of input image
    newBlack = numel(find(BW_ink==0));
    newWhite = numel(find(BW_ink==1));
    newRatio = newBlack/newWhite;
    
    %subtract base ratio from new ratio
    classPercent = newRatio - baseRatio;
    
    %classify image based on ratio result
    if classPercent < 0.01
        rating = 5;
    elseif classPercent < 0.05 
        rating = 4;
    elseif classPercent < 0.15
        rating = 3;
    elseif classPercent < 0.35
        rating = 2;
    elseif classPercent < 0.65
        rating = 1;
    else
        rating = 0;
    end
    
    if classPercent < 0
        warning("The value is negative. This could mean the baseline image" ...
        + " is flakier than the new image but it is more likely that the methodology" ...
        + " for classification is flawed.");
    end
    disp("The classification is " + rating + " (" + num2str(classPercent*100) + "% area affected).");
    
%     imwrite(BW_ink, 'BW_ink_norm.png');  % Optionally writes new image to file
    
end

function baseRatio = GetBaseline(filename)
    
    baseImg = imread(filename);
    
    %rbg2gray reduces amount of matrices from 3 to 1
    baseImg = rgb2gray(baseImg);
    
    %imbinarize converts all values to 0 (black) or 1 (white)
    baseImg = imbinarize(baseImg);
    imshow(baseImg);
    
    baseBlack = numel(find(baseImg == 0));
    baseWhite = numel(find(baseImg == 1));
    baseRatio = baseBlack / baseWhite;
end

%Automatically generated code below.
%Do not worry too much about how this works but feel free to use a
%different or better method to change the image to black and white.

function [BW,maskedImage] = segmentImage(RGB)
    %segmentImage Segment image using auto-generated code from imageSegmenter app
    %  [BW,MASKEDIMAGE] = segmentImage(RGB) segments image RGB using
    %  auto-generated code from the imageSegmenter app. The final segmentation
    %  is returned in BW, and a masked image is returned in MASKEDIMAGE.

    % Auto-generated by imageSegmenter app on 23-Jul-2021
    %----------------------------------------------------


    % Convert RGB image into L*a*b* color space.
    X = rgb2lab(RGB);

    % Auto clustering
    s = rng;
    rng('default');
    L = imsegkmeans(single(X),2,'NumAttempts',2);
    rng(s);
    BW = L == 2;

    % Create masked image.
    maskedImage = RGB;
    maskedImage(repmat(~BW,[1 1 3])) = 0;
end


